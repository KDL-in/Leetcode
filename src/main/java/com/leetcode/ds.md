## 1. 数据结构

要求实现数据结构的题目。

核心就是，各种集合轮子的应用，需要考虑他们的API，各种操作的复杂度。以及，实现轮子的能力。

## 2. 问题

#### 2.1 并查集

用于连通性判断，路径压缩，核心代码如下：

```java
        private int find(int x) {
            while (parent[x] != x) {
                // 进行路径压缩
                parent[x] = parent[parent[x]];
                x = parent[x];
            }
            return x;
        }
```

- 130，**被包围的x**，找到被包围的x，核心的连通性判断
- 990，**等式是否成立**，核心仍是连通性判断

#### 2.2 `LinkedHashMap`

`linkedList`的插入删除非常快$O(1)$，但是本身无法做到快速定位$O(N)$，因而结合`hashMap`，为其提供value到node节点引用的快速定位功能。

- 146，**实现LRU Cache**，常见的的一种队列策略的实现，主要就是`linkedHashMap`的应用
- 460，**实现LFU Cache**，按频率，比较难想到很全面的实现，比如这个 题，应该使用`freq -> linkedHashMap`才能很好保证LFU的各项效率。

#### 2.3 **单调栈和队列**

**单调栈**

最经典的案例是：一排人站成一列找身高更高的——此时身高低的会被直接挡住，只会看到更高的。

实现的基本思想是，比入栈元素小的栈顶元素都会被出栈。这使得栈保持严格的单调性（单调递减）。

从另一个角度，若不然，则会出现5 1 2 4，事实上被4挡住的1 2 对于后面随后的计算是没有用处的，在找到更高的人的场景下，你只能看到4.

算法复杂度的思考很经典，考虑所有元素有且仅有出栈入栈一次。 

````java
int[] ans = new int[T.length];
Stack<Integer> stack = new Stack();
for (int i = T.length - 1; i >= 0; --i) {
    while (!stack.isEmpty() && T[i] >= T[stack.peek()]) stack.pop();
    ans[i] = stack.isEmpty() ? 0 : stack.peek() - i;
    stack.push(i);
}
````

- 496，下一个更大的数，两数组，单调栈
- 503，循环数组，下一个更大的数，两次遍历
- 739，下一个更温暖的日子需要多久，变体
- 316，数组去重，要求最小字典序以及保存相对位置，复杂的去重，单调栈的应用。

**单调队列**

它们保证单调的基本手段是——元素进入前，首先移除队列末尾不符合单调条元素。

详细可以参考题目 239的注解。

单调队列的模板。

````java
class ManoQueue{
    private LinkedList<Integer> list;

    public ManoQueue() {
        list = new LinkedList<>();
    }

    public void push(int cur) {
        while (!list.isEmpty() && cur > list.getLast()) list.removeLast();
        list.addLast(cur);
    }

    public int max() {
        return list.getFirst();
    }

    public void pop(int cur) {
        if (list.getFirst() == cur)  list.removeFirst();
    }
}
````

滑动窗口的模板。

````java
        for (int i = 0; i < nums.length; i++) {
            if (i < k - 1) {
                q.push(nums[i]);
            } else {
                q.push(nums[i]);
                res[idx++] = q.max();
                q.pop(nums[i - k + 1]);
            }
        }
````

- 239，返回滑动窗口的最大值，在O(1)的时间完成该操作，单调队列解决。

#### 2.4 堆

-  [最大堆实现](datastructure\head\最大堆实现.md) 

- 295，流的中位数，大小堆

**多个有序列表的合并**

````java
所有列表头节点进堆
while (!pq.isEmpty() && r.size() < 10) {
     tw = pq.poll();
     r.add(tw.tid);
     if (tw.next!=null)pq.offer(tw.next);
}
````

- 355，推特模拟，多个有序列表的合并，面向对象编程

#### 2.5 **队列和栈的相互实现**

- 225，使用队列实现栈，单队列，pop的时候将n-1个元素重新放到队尾。
- 232，栈实现队列，双栈，使用双栈两次改变顺序还原队列顺序

#### 2.6 二分搜索

二分搜索需要记住模板，边界条件要求比较严格。

````java
        while (lo < hi) {
            mid = (lo + hi) / 2;
            if (!isPossible(weights, mid, D)) lo = mid + 1;
            else hi = mid;
        }
````

- 875，吃完所有香蕉，每天最少吃多少。确定上下界，二分搜索
- 1011，运完所有包裹，最少容量。确定上下界，二分搜索。

#### 2.7 双指针

通过双指针，巧妙地解决某些问题。

**快慢指针**

- 19，删除倒数第k个节点，快慢指针，dummy哨兵
- 141，寻找环
- 142，寻找环并找到起点，快慢指针进阶
- 876，链表中值

**左右指针**

- 167，有序数组中寻找两数之和，严格O（N）
- 344，翻转数组

#### 2.8 滑动窗口

一种非常典型的编程思想，滑动窗口。详细展开： [滑动窗口.md](datastructure\array\window\滑动窗口.md) 

专门针对滑动窗口的问题，框架更是一看就懂。

````java
while (right < s.length()) {
    //移动窗口右边时机，向窗口添加元素
    w.add(s.charAt(right++));
    // 判断是否需要移动窗口坐标，移除元素
    while (w.check()) {
        w.remove(s.charAt(left++));
    }
    // debug时机，查看当前窗口，或打印窗口内容
    // 检查合法条件时机，以下为举例
    size = Math.max(size, w.size);
}
````

这个框架的好处是非常清晰，主要逻辑——添加元素，删除元素，检查合法性，用什么来帮助快速检查合法性都交给窗口。窗口对象需要实现这些方法。

**定长窗口**

- 3，不重复的最长子串，移动右侧滑动窗口，窗口需要检查是否出现重复，重复则移动左边
- 76，寻找包含目标t的最小字串，移动右侧，滑动窗口，当t被覆盖时，移动左边

**不定长窗口**

- 567，s2是否包含s1全排列之一，左右轮流移动，检查是否覆盖
- 438，s2是否包含s1的异构，和567基本相同

#### 2.9 不使用额外空间

数组的原地修改。简单题。

**原地修改**

- 238，数组累乘，除了当前数，不得使用额外空间，不得用除法，使用左右两次遍历

- 26，有序数组去重，不得使用额外空间
- 27， 删除数组中的val，不得使用额外空间
- 83，有序链表去重
- 283，移动0到数组末尾

**其他**

- 238，数组累乘，除了当前数，不得使用额外空间，不得用除法，使用左右两次遍历

#### 2.10 stack

- 20，检查括号合法性

#### 2.11 LinkList


没有框架。链表是最简单的数据结构之一，编程思想可以视为二叉树单向版。O(N)经常是无法避免的。难点只是指针细节。


- 92，翻转链表，递归，迭代都能做，哨兵技巧，细节问题
- 25，按组翻转，同上
- 234，回文判断，利用翻转实现O(1)的空间复杂度

####  2.20 其他

**数组+Hash**

实现紧凑的按值取rank，利用交换到数组末尾的方式进行删除，hash维护val2idx，支持O(1)的插入删除特定值，以及紧凑的存储。

- 380，实现紧凑的set，支持随机获得集合元素
- 710，随机选择[0, n）但不在黑名单中的数字，使用该思想实现

**求和**

- 1，求目标和的两个下标，hash应用